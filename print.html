<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zinc v0.1.5</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The official Zinc book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="01-design-background.html"><strong aria-hidden="true">1.</strong> Design background</a></li><li class="chapter-item expanded "><a href="02-getting-started/01-first-circuit.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-getting-started/02-more-complex-example.html"><strong aria-hidden="true">2.1.</strong> More complex example</a></li></ol></li><li class="chapter-item expanded "><a href="03-basic-concepts/00-overview.html"><strong aria-hidden="true">3.</strong> Basic concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-basic-concepts/01-input-output.html"><strong aria-hidden="true">3.1.</strong> Input and output</a></li><li class="chapter-item expanded "><a href="03-basic-concepts/02-builtin-functions.html"><strong aria-hidden="true">3.2.</strong> Built-in functions</a></li><li class="chapter-item expanded "><a href="03-basic-concepts/03-standard-library.html"><strong aria-hidden="true">3.3.</strong> Standard library</a></li></ol></li><li class="chapter-item expanded "><a href="04-variables-and-types/00-overview.html"><strong aria-hidden="true">4.</strong> Variables and types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-variables-and-types/01-variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/00-overview.html"><strong aria-hidden="true">4.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/01-scalar.html"><strong aria-hidden="true">4.2.1.</strong> Scalar</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/02-arrays.html"><strong aria-hidden="true">4.2.2.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/03-tuples.html"><strong aria-hidden="true">4.2.3.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/04-structures.html"><strong aria-hidden="true">4.2.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/05-enumerations.html"><strong aria-hidden="true">4.2.5.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/06-strings.html"><strong aria-hidden="true">4.2.6.</strong> Strings</a></li><li class="chapter-item expanded "><a href="04-variables-and-types/02-types/07-casting-and-conversions.html"><strong aria-hidden="true">4.2.7.</strong> Casting and conversions</a></li></ol></li><li class="chapter-item expanded "><a href="04-variables-and-types/03-functions.html"><strong aria-hidden="true">4.3.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="05-operators/00-overview.html"><strong aria-hidden="true">5.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-operators/01-arithmetic.html"><strong aria-hidden="true">5.1.</strong> Arithmetic</a></li><li class="chapter-item expanded "><a href="05-operators/02-bitwise.html"><strong aria-hidden="true">5.2.</strong> Bitwise</a></li><li class="chapter-item expanded "><a href="05-operators/03-comparison.html"><strong aria-hidden="true">5.3.</strong> Comparison</a></li><li class="chapter-item expanded "><a href="05-operators/04-logical.html"><strong aria-hidden="true">5.4.</strong> Logical</a></li><li class="chapter-item expanded "><a href="05-operators/05-casting.html"><strong aria-hidden="true">5.5.</strong> Casting</a></li><li class="chapter-item expanded "><a href="05-operators/06-access.html"><strong aria-hidden="true">5.6.</strong> Access</a></li><li class="chapter-item expanded "><a href="05-operators/07-range.html"><strong aria-hidden="true">5.7.</strong> Range</a></li><li class="chapter-item expanded "><a href="05-operators/08-assignment.html"><strong aria-hidden="true">5.8.</strong> Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="06-expressions/00-overview.html"><strong aria-hidden="true">6.</strong> Expressions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-expressions/01-literals.html"><strong aria-hidden="true">6.1.</strong> Literals</a></li><li class="chapter-item expanded "><a href="06-expressions/02-blocks.html"><strong aria-hidden="true">6.2.</strong> Blocks</a></li><li class="chapter-item expanded "><a href="06-expressions/03-conditionals.html"><strong aria-hidden="true">6.3.</strong> Conditionals</a></li></ol></li><li class="chapter-item expanded "><a href="07-statements/00-overview.html"><strong aria-hidden="true">7.</strong> Statements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07-statements/01-declaration.html"><strong aria-hidden="true">7.1.</strong> Declaration</a></li><li class="chapter-item expanded "><a href="07-statements/02-expression.html"><strong aria-hidden="true">7.2.</strong> Expression</a></li><li class="chapter-item expanded "><a href="07-statements/03-control.html"><strong aria-hidden="true">7.3.</strong> Control</a></li></ol></li><li class="chapter-item expanded "><a href="08-virtual-machine/00-overview.html"><strong aria-hidden="true">8.</strong> Virtual machine</a></li><li class="chapter-item expanded "><a href="09-zargo-circuit-manager/00-overview.html"><strong aria-hidden="true">9.</strong> Zargo circuit manager</a></li><li class="chapter-item expanded "><a href="10-schnorr-signature-tool/00-overview.html"><strong aria-hidden="true">10.</strong> Schnorr signature tool</a></li><li class="chapter-item expanded "><a href="appendix/_overview.html"><strong aria-hidden="true">11.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/A-grammar-lexical.html"><strong aria-hidden="true">11.1.</strong> A - Lexical grammar</a></li><li class="chapter-item expanded "><a href="appendix/B-grammar-syntax.html"><strong aria-hidden="true">11.2.</strong> B - Syntax grammar</a></li><li class="chapter-item expanded "><a href="appendix/C-keywords.html"><strong aria-hidden="true">11.3.</strong> C - Keywords</a></li><li class="chapter-item expanded "><a href="appendix/D-built-in-functions.html"><strong aria-hidden="true">11.4.</strong> D - Built-in functions</a></li><li class="chapter-item expanded "><a href="appendix/E-standard-library.html"><strong aria-hidden="true">11.5.</strong> E - Standard library</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Zinc v0.1.5</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img style="display: block; margin: auto;" width="200" height="200" src="./zinc-color.png"/>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>Recent rapid advances in R1CS-based SNARKs finally make application of
zero-knowledge proofs practical for bringing scalability and privacy to blockchains.</p>
<p>At the same time, most existing languages and frameworks for constructing R1CS
circuits, while being useful in academic research and prototyping, do not
provide a satisfying degree of expressiveness and brevity to write readable and
easily maintainable programs. A notable exception is <em>xJsnark</em>, but being
based on Java it lacks a lot of safety features of modern functional languages.</p>
<p>Further, existing frameworks completely lack functionality specific for
smart contracts. Security and safety aspects are crucial for developing smart
contracts since they deal with valuable financial assets. Modern smart contract
languages, such as <em>Simplicity</em> or Libra's <em>Move</em>, deliberately made design
choices that favor safety and formal verifiability of the code over generalistic
expressiveness.</p>
<p>Zinc was created to fill the gap between these two worlds: provide a smart
contract language optimized for R1CS circuits, which is reliable and simple at
the same time, and can be quickly learned by a large number of software developers.</p>
<p>We decided to borrow the Rust syntax and semantics. Zinc is a subset of Rust
with minor differences dictated by the subtleties of R1CS circuits. It is easily
learnable by any developer familiar with Rust, Golang, C++ or other C-like
languages. Also, experience with Solidity will help in understanding some smart
contract specifics.</p>
<p>The language is under heavy development, so many of its aspects will eventually
be improved or changed. However, the basic principles, such as security and
simplicity, will never be questioned.</p>
<h1><a class="header" href="#design-background" id="design-background">Design background</a></h1>
<p>The goal of Zinc is to make writing safe zero-knowledge programs and ZKP-based
smart contracts easy. It has been designed with the following principles in mind:</p>
<ul>
<li><strong>Security</strong>. It should be easy to write deterministic and secure programs.
Conversely, it should be hard to write code to exploit some possible
vulnerabilities found in other programming languages.</li>
<li><strong>Safety</strong>. The language must enforce the most strict semantics available,
such as a strong static explicit type system.</li>
<li><strong>Efficiency</strong>. The code should compile to the most efficient circuit possible.</li>
<li><strong>Cost-exposition</strong>. Performance costs that cannot be optimized efficiently
must be made explicit to the developers. An example is the requirement to
explicitly specify the loop range with constants.</li>
<li><strong>Simplicity</strong>. Anyone familiar with C-like languages (Javascript, Java,
Golang, C++, Rust, Solidity, Move) should be able to learn Zinc quickly and
with minimum effort.</li>
<li><strong>Readability</strong>. The code in Zinc should be easily readable to anybody
familiar with the C++ language family. There should be no counter-intuitive concepts.</li>
<li><strong>Minimalism</strong>. Less code is better. There should ideally be only one way to
do something efficiently. Complexity should be reduced.</li>
<li><strong>Expressiveness</strong>. The language should be powerful enough to make building
complex programs easy.</li>
<li><strong>Turing incompleteness</strong>. Unbounded looping and recursion are not permitted
in Zinc. This not only allows more efficient R1CS circuit construction but
also makes formal verifiability about the call and stack safety easier and
eliminates the gas computation problem inherent to Turing-complete smart
contract platforms, such as EVM.</li>
</ul>
<h1><a class="header" href="#key-features" id="key-features">Key features</a></h1>
<ul>
<li>Type safety</li>
<li>Type inference</li>
<li>Immutability</li>
<li>Movable resources as a first-class citizen</li>
<li>Module definition and import</li>
<li>Expressive syntax</li>
<li>Industrial-grade compiler optimizations</li>
<li>Turing incompleteness: no recursion or unbounded looping</li>
<li>Flat learning curve for Rust/JS/Solidity/C++ developers</li>
</ul>
<h1><a class="header" href="#comparison-to-rust" id="comparison-to-rust">Comparison to Rust</a></h1>
<p>Zinc is designed specifically for ZK-circuits and ZKP-based smart contract
development, so some differences from Rust are inevitable.</p>
<h2><a class="header" href="#type-system" id="type-system">Type system</a></h2>
<p>We need to adapt the type system to be efficiently representable in
finite fields, which are the basic building block of R1CS. The current type
system mostly follows Rust, but some aspects are borrowed from smart contract
languages. For example, Zinc provides integer types with 1-byte step sizes,
like those in Solidity.</p>
<h2><a class="header" href="#ownership-and-borrowing" id="ownership-and-borrowing">Ownership and borrowing</a></h2>
<p>Memory management is very different in R1CS
circuits compared to the von Neumann architecture. Also, since R1CS does not
imply parallel programming patterns, a lot of elements of the Rust design would
be unnecessary and redundant. Zinc has no ownership mechanism found in Rust
because all variables will be passed by value. The borrowing mechanism is still
being designed, but probably, only immutable references will be allowed shortly.</p>
<h2><a class="header" href="#loops-and-recursion" id="loops-and-recursion">Loops and recursion</a></h2>
<p>Zinc is a Turing-incomplete language, as it does not allow recursion and
variable loop indexes. Every loop range must be bounded with constant literals
or expressions.</p>
<h1><a class="header" href="#first-circuit" id="first-circuit">First circuit</a></h1>
<h2><a class="header" href="#zinc-installation" id="zinc-installation">Zinc installation</a></h2>
<p>To start using the Zinc framework, do the following:</p>
<ol>
<li>Download its <a href="https://github.com/zpreview/public/releases">binaries</a> for your OS and architecture.</li>
<li>Add the folder with the binaries to <code>PATH</code></li>
<li>Use the binaries via your favorite terminal</li>
</ol>
<p>The Zinc framework consists of three tools:</p>
<ul>
<li><code>zargo</code> circuit manager</li>
<li><code>znc</code> Zinc compiler</li>
<li><code>zvm</code> Zinc virtual machine</li>
</ul>
<p><code>zargo</code> can use the compiler and virtual machine through its interface,
so you will only need <code>zargo</code> to work with your circuits.</p>
<p>For more information on <code>zargo</code>, check out this <a href="02-getting-started/../09-zargo-circuit-manager/00-overview.html">chapter</a>.</p>
<p>Let's now move on to writing 'Hello, World!' in Zinc!</p>
<h2><a class="header" href="#the-visual-studio-code-extension" id="the-visual-studio-code-extension">The Visual Studio Code extension</a></h2>
<p>There is a syntax highlighting extension for Zinc called <code>Zinc Syntax Highligthing</code>.
The IDE should recommend installing it once you have opened a Zinc file!</p>
<h2><a class="header" href="#creating-the-circuit" id="creating-the-circuit">Creating the circuit</a></h2>
<p>Let's create our first circuit, which will be able to prove knowledge of
some <code>sha256</code> hash preimage:</p>
<pre><code>zargo new preimage
cd preimage
</code></pre>
<p>The command above will create a directory with <code>Zargo.toml</code> manifest and the <code>src/</code>
folder with an entry point module <code>main.zn</code>.</p>
<p>Let's replace the <code>main.zn</code> contents with the following code:</p>
<pre><code class="language-rust no_run noplaypen">use std::crypto::sha256;
use std::convert::to_bits;
use std::array::pad;

const FIELD_SIZE: u64 = 254;
const FIELD_SIZE_PADDED: u64 = FIELD_SIZE + 2 as u64;
const SHA256_HASH_SIZE: u64 = 256;

fn main(preimage: field) -&gt; [bool; SHA256_HASH_SIZE] {
    let preimage_bits: [bool; FIELD_SIZE] = to_bits(preimage);
    let preimage_bits_padded: [bool; FIELD_SIZE_PADDED] = pad(preimage_bits, 256, false);
    sha256(preimage_bits_padded)
}
</code></pre>
<h2><a class="header" href="#all-in-one-command" id="all-in-one-command">All-in-one command</a></h2>
<p>When you have finished writing the code, run <code>zargo proof-check</code>. This command
will build and run the circuit, generate keys for trusted setup, generate a proof
and verify it.</p>
<h2><a class="header" href="#step-by-step" id="step-by-step">Step by step</a></h2>
<p>Let's get through each step of the command above manually to better understand
what is under the hood. Before you start, run <code>zargo clean</code> to remove all the
build artifacts.</p>
<h3><a class="header" href="#building-the-circuit" id="building-the-circuit">Building the circuit</a></h3>
<p>Now, you need to compile the circuit into Zinc bytecode:</p>
<p><code>zargo build</code></p>
<p>The command above will write the bytecode to the <code>build</code> directory located in
the project root. There is also a file called <code>witness.json</code> in the
<code>build</code> directory, which is used to provide the secret witness data to the circuit.</p>
<h3><a class="header" href="#running-the-circuit" id="running-the-circuit">Running the circuit</a></h3>
<p>Before you run the circuit, open the <code>data/witness.json</code> file with
your favorite editor and fill it with some meaningful values.</p>
<p>Now, execute <code>zargo run &gt; data/public-data.json</code> to run the circuit and
write the resulting public data to a file.</p>
<blockquote>
<p>There is a useful tool called <code>jq</code>. You may use it together with <code>zargo run</code>
to highlight, edit, filter the output data before writing it to the file:
<code>zargo run | jq &gt; data/public-data.json</code>.</p>
<p>For more information on <code>jq</code>, visit the <a href="https://stedolan.github.io/jq/manual/">official manual</a>.</p>
</blockquote>
<h3><a class="header" href="#trusted-setup" id="trusted-setup">Trusted setup</a></h3>
<p>To be able to verify proofs, you must create a pair of keys for the prover and
the verifier.</p>
<p>To generate a new pair of proving and verifying keys, use this command:</p>
<pre><code class="language-bash">zargo setup
</code></pre>
<h3><a class="header" href="#generating-a-proof" id="generating-a-proof">Generating a proof</a></h3>
<p>To generate a proof, provide the witness and public data to the Zinc VM with
the following command:</p>
<pre><code class="language-bash">zargo prove &gt; proof.txt
</code></pre>
<p>This will also write the program's output to <code>data/public-data.json</code> which is later
used by the verifier.</p>
<h3><a class="header" href="#verifying-a-proof" id="verifying-a-proof">Verifying a proof</a></h3>
<p>Before verifying a proof, make sure that the prover and verifier use the same
version of the Zinc framework.
Some versions may be compatible, but it is to be decided yet.</p>
<p>To verify a proof, pass it to the Zinc VM with the same public data you used to
generated it, and the verification key:</p>
<pre><code class="language-bash">zargo verify &lt; proof.txt
</code></pre>
<p>Congratulations! You have developed your first circuit and verified your first
Zero-Knowledge Proof!</p>
<p>Feel free to proceed to the next chapters to know more about the Zinc framework!</p>
<h1><a class="header" href="#merkle-proof" id="merkle-proof">Merkle proof</a></h1>
<p>In this chapter, we will implement a circuit able to validate the Merkle tree
root hash.</p>
<p>At this stage of reading the book, you may be unfamiliar with some language
concepts. So, if you struggle to understand some examples, you are welcome to
read the rest of the book first, and then come back here.</p>
<p>Our circuit will accept the tree node path, address, and the balance available
as the secret witness data. The public data will be the Merkle tree root hash.</p>
<h2><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h2>
<p>Let's create a new circuit called <code>merkle-proof</code>:</p>
<pre><code class="language-bash">zargo new merkle-proof
cd merkle-proof
</code></pre>
<p>Now, you can open the project in your favorite IDE and go to <code>src/main.zn</code>,
where we are going to start writing the circuit code.</p>
<h2><a class="header" href="#defining-types" id="defining-types">Defining types</a></h2>
<p>Let's start by defining the secret witness data arguments and the public data
return type.</p>
<pre><pre class="playground"><code class="language-rust">struct PublicInput {
    root_hash: [bool; 256],
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [[bool; 256]; 10] // the hash path to the node
) -&gt; PublicInput {
    // ...
}
</code></pre></pre>
<p>As you can see, some complex types are used in several places of our code, so
it is very convenient to create an alias for such type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Sha256Digest = [bool; 256];
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#creating-functions" id="creating-functions">Creating functions</a></h2>
<p>Now, we will write a function to calculate the <code>sha256</code> hash of
our balance. We need it to verify the balance stored within the leaf node at our
Merkle tree path.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}
<span class="boring">}
</span></code></pre></pre>
<p>The function accepts <code>balance</code> we passed as secret witness data, converts it
into a bit array of length 254 (elliptic curve field length), and pads the
array with 2 extra zero bits, since we are going to pass 256 bit vector to the
<code>sha256</code> function.</p>
<p>We have also used here three functions from the Zinc <a href="02-getting-started/../appendix/E-standard-library.html">standard library</a>
from three different modules. The <code>std::crypto::sha256</code>-like paths might seem a
bit verbose, but we will solve this problem later.</p>
<p>At this stage, this is how our code looks like:</p>
<pre><pre class="playground"><code class="language-rust">type Sha256Digest = [bool; 256];

struct PublicInput {
    root_hash: Sha256Digest,
}

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [Sha256Digest; 10] // the hash path to the node
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    // ...
}
</code></pre></pre>
<p>Now, we need a function to calculate a tree node hash:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    // Casting to u16 is needed to make the range types equal,
    // since 0 will be inferred as u8, and 256 - as u16.
    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}
<span class="boring">}
</span></code></pre></pre>
<p>The Zinc standard library does not support array concatenation yet, so, for now,
we will do it by hand, allocating an array to contain two leaf node digests,
then put the digests together and hash them with <code>std::crypto::sha256</code>.</p>
<p>Finally, let's define a function to calculate the hash of the whole tree:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as an array of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            [current, merkle_path[i]] // [Sha256Digest; 2]
        } else {
            [merkle_path[i], current] // [Sha256Digest; 2]
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    // return the root node hash
    current
}
<span class="boring">}
</span></code></pre></pre>
<p>Congratulations! Now we have a working circuit able to verify the Merkle proof!</p>
<pre><pre class="playground"><code class="language-rust">// main.zn

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    // Casting to u16 is needed to make the range types equal,
    // since 0 will be inferred as u8, and 256 - as u16.
    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as an array of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            [current, merkle_path[i]] // [Sha256Digest; 2]
        } else {
            [merkle_path[i], current] // [Sha256Digest; 2]
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    // return the root node hash
    current
}

struct PublicInput {
    root_hash: Sha256Digest,
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10]
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    let root_hash = restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<h2><a class="header" href="#defining-a-module" id="defining-a-module">Defining a module</a></h2>
<p>Our <code>main.zn</code> module has got a little overpopulated by now, so let's move our
functions to another one called <code>merkle</code>. At first, create a file called <code>merkle.zn</code>
in the <code>src</code> directory besides <code>main.zn</code>. Then, move everything above the
<code>PublicInput</code> definition to that file. Our <code>main.zn</code> will now look like this:</p>
<pre><pre class="playground"><code class="language-rust">struct PublicInput {
    root_hash: Sha256Digest, // undeclared `Sha256Digest`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10] // undeclared `Sha256Digest`
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance); // undeclared `balance_hash`

    let root_hash = restore_root_hash( // undeclared `restore_root_hash`
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<p>This code will not compile, as we have several items undeclared now! Let's
define our <code>merkle</code> module and resolve the function paths:</p>
<pre><pre class="playground"><code class="language-rust">mod merkle; // defined a module

struct PublicInput {
    root_hash: merkle::Sha256Digest, // use a type declaration from `merkle`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [merkle::Sha256Digest; 10] // use a type declaration from `merkle`
) -&gt; PublicInput {
    let leaf_hash = merkle::balance_hash(balance); // call a function from `merkle`

    // call a function from `merkle`
    let root_hash = merkle::restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<p>Perfect! Now all our functions and types are defined. By the way, let's have a
glance at our <code>merkle</code> module, where you can find another improvement!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::crypto::sha256; // an import

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance);
    let bits_padded = std::array::pad(bits, 256, false);
    sha256(bits_padded)
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512];

    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    sha256(data)
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash;

    for i in 0..10 {
        let left_and_right = if address[i] {
            [current, merkle_path[i]]
        } else {
            [merkle_path[i], current]
        };

        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    current
}
<span class="boring">}
</span></code></pre></pre>
<p>You may notice a <code>use</code> statement at the first line of code. It is an import statement
which is designed to prevent using long repeated paths in our code. As you can see,
now we call the standard library function like this <code>sha256(data)</code>, but not like
that <code>std::crypto::sha256(data)</code>.</p>
<h2><a class="header" href="#finalizing" id="finalizing">Finalizing</a></h2>
<p>Congratulations, you are an experienced Zinc developer!
Now, you may build the circuit, generate and verify a proof, like it was
explained in the <a href="02-getting-started/./01-first-circuit.html">previous chapter</a>,
and move on to reading the rest of the book!</p>
<h1><a class="header" href="#basic-concepts" id="basic-concepts">Basic concepts</a></h1>
<p>A Zinc project consists of an entry point file called <code>main.zn</code> and zero or more
module files whose contents can be imported into the main file.</p>
<p>The entry point file must contain the <code>main</code> function, which accepts secret witness
data and returns public input data. For more detail, see the
<a href="03-basic-concepts/./01-input-output.html">next section</a>.</p>
<p>Module files may contain only declarations of types, functions, and constants.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#entry-point-file" id="entry-point-file">Entry point file</a></h3>
<pre><code class="language-rust no_run noplaypen">/// 
/// 'src/main.zn'
///
/// Proves a knowledge of a cube root `r` for a given public input `x`.
///

mod simple_math;

use simple_math::cube;

fn main(x: field, r: field) -&gt; field {
    assert!(x == cube(r), &quot;x == r ^ 3&quot;);
    x
}
</code></pre>
<h3><a class="header" href="#module-simple_math-file" id="module-simple_math-file">Module <code>simple_math</code> file</a></h3>
<pre><code class="language-rust no_run noplaypen">/// 
/// 'src/simple_math.zn'
/// 

/// Returns x^3.
fn cube(x: field) -&gt; field {
    x * x * x
}
</code></pre>
<h1><a class="header" href="#input-and-output" id="input-and-output">Input and output</a></h1>
<p>In terms of zero-knowledge circuits, the information that we are trying to prove
valid is called <strong>public input</strong>. And the secret piece of information that may
be known only by prover is called <strong>witness</strong>.</p>
<p>In the Zinc framework, the program's <strong>result</strong> becomes <strong>public input</strong>.
That means that whatever the <code>main</code> function returns should be known by verifier.
All other runtime values including <strong>arguments</strong> represent circuit's <strong>witness</strong>.</p>
<p>So when verifier checks the program's <strong>result</strong> and the <strong>proof</strong>
it is safe to state that:</p>
<blockquote>
<p>There is some set of <strong>arguments</strong> known to <strong>prover</strong>, which,
being provided into <strong>program</strong> yields the same <strong>output</strong>.</p>
</blockquote>
<p>The prover must provide program's arguments to generate the result and proof.</p>
<p>Verifier will use the proof to check that the result has been obtained by
executing the program.</p>
<p>The following example illustrates a circuit proving knowledge of some
<code>sha256</code> hash preimage:</p>
<pre><code class="language-rust no_run noplaypen">use std::crypto::sha256;

fn main(preimage: [bool; 256]) -&gt; [bool; 256] {
    sha256(preimage)
}
</code></pre>
<h1><a class="header" href="#built-in-functions" id="built-in-functions">Built-in functions</a></h1>
<p>There are several built-in functions, which can be called directly from
anywhere in your code.</p>
<h2><a class="header" href="#assert" id="assert"><code>assert!()</code></a></h2>
<p>This function creates a custom constraint in any place of your code.
Using <code>assert!()</code> you can check whether some condition is true
and make the circuit exit with an error if otherwise:</p>
<pre><code class="language-rust no_run noplaypen">const BAD_VALUE: u8 = 42;

fn wrong(a: u8, b: u8) -&gt; u8 {
    let c = a + b - BAD_VALUE;
    assert!(a + b == c, &quot;always fails&quot;);
    c
}
</code></pre>
<h2><a class="header" href="#dbg" id="dbg"><code>dbg!()</code></a></h2>
<p>This function prints data to the terminal and is used only for debugging purposes.</p>
<p>The first argument is the format string, where each <code>{}</code> placeholder is replaced
with a corresponding value from the rest of the arguments. The number of placeholders
must be equal to the number of the arguments not including the format string.</p>
<pre><code class="language-rust no_run noplaypen">// a = 5, b = 3
fn print_sum(a: u8, b: u8) {
    dbg!(&quot;{} + {} = {}&quot;, a, b, a + b); // prints '5 + 3 = 8'
}
</code></pre>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>To call such a function, use the <code>&lt;identifier&gt;!(arg1, arg2, ...)</code> syntax,
as in the following example:</p>
<pre><code class="language-rust no_run noplaypen">fn main(/* ... */) {
    let value: u8 = 42;
    dbg!(&quot;{}&quot;, value);
    assert!(value == 42);
}
</code></pre>
<blockquote>
<p>If you are familiar with Rust, it can resemble the macro syntax found there, but
actually, these functions have nothing to do with macros. Instead, they
represent some special Zinc VM instructions.</p>
</blockquote>
<p>The exhaustive list of function signatures is provided in <a href="03-basic-concepts/../appendix/D-built-in-functions.html">Appendix D</a>.</p>
<h1><a class="header" href="#standard-library" id="standard-library">Standard library</a></h1>
<p>The standard library is currently located in a built-in module called <code>std</code>.
The library contains three modules for now:</p>
<ul>
<li><code>crypto</code> - cryptographic and hash functions
<ul>
<li><code>ecc</code> - elliptic curve cryptography</li>
<li><code>schnorr</code> - EDDSA signatyre verification</li>
</ul>
</li>
<li><code>convert</code> - bit array conversion functions</li>
<li><code>array</code> - array processing functions</li>
<li><code>ff</code> - finite field functions</li>
</ul>
<p>All the function signatures are listed in <a href="03-basic-concepts/../appendix/E-standard-library.html">Appendix E</a>.</p>
<p>Standard library items can be used directly or be imported with <code>use</code>:</p>
<pre><code class="language-rust no_run noplaypen">use std::crypto::sha256;

fn main(preimage: [bool; 256]) -&gt; ([bool; 256], (field, field)) {
    let input_sha256 = sha256(preimage); // through import
    dbg!(input_sha256);

    let input_pedersen = std::crypto::pedersen(preimage); // directly
    dbg!(input_pedersen);

    (input_sha256, input_pedersen)
}
</code></pre>
<h1><a class="header" href="#variables-and-types" id="variables-and-types">Variables and types</a></h1>
<p>This chapter describes the Zinc language concepts. Here you will learn about
variables, types, and functions.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>As it was said before, Zinc is mostly about safety and security. Thus,
variables are immutable by default. If you are going to change their values,
you must explicitly mark them as mutable. It protects your data from accidental
mutating where the compiler is unable to check your intentions.</p>
<pre><code class="language-rust no_run noplaypen">fn test() {
    let x = 0;
    // compile error: mutating an immutable variable
    // x = 42;

    let mut y = 0;
    y = 42; // ok
}
</code></pre>
<p>If you are familiar with Rust, you will not have any trouble understanding this
concept, since the syntax and semantics are almost identical. However, pattern
matching and destructuring are not implemented yet.</p>
<p>Immutable variables are similar to constants. Like with constants, you cannot
change the immutable variable value. However, constants cannot infer their type
and you must specify it explicitly.</p>
<blockquote>
<p>In contrast to Rust, variables can only be declared in functions. If you need a
global variable, you should declare a constant instead. This limitation is devised to
prevent unwanted side effects, polluting the global namespace, and bad design.</p>
</blockquote>
<pre><code class="language-rust no_run noplaypen">const VALUE: field = 0;

fn test() {
    let variable = VALUE;
}
</code></pre>
<p>Variable shadowing can be a convenient feature, but Zinc is going to enforce
warning-as-error development workflow, forbidding shadowing as a potentially
unsafe trick. You should use mutable variables and type suffixes if you want
several variables with similar logical meaning.</p>
<pre><code class="language-rust no_run noplaypen">fn test() {
    let mut x = 5;
    {
        // compile error: redeclared variable 'x'
        // let x = 25;
    }
    // compile error: redeclared variable 'x'
    // let x = 25;

    x = 25; // ok
}
</code></pre>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Zinc is a statically typed language, thus all the variables must have a type
known at the compile time. Strict type system allows to catch the majority of
runtime errors, which are very common to dynamically typed languages. Zinc type
system closely resembles that of Rust, but with some modifications, limitations,
and restrictions.</p>
<p>Types are divided into several groups:</p>
<ul>
<li><a href="04-variables-and-types/02-types/./01-scalar.html">Scalar</a></li>
<li><a href="04-variables-and-types/02-types/02-arrays.html">Array</a></li>
<li><a href="04-variables-and-types/02-types/03-tuples.html">Tuple</a></li>
<li><a href="04-variables-and-types/02-types/04-structures.html">Structure</a></li>
<li><a href="04-variables-and-types/02-types/05-enumerations.html">Enumeration</a></li>
<li><a href="04-variables-and-types/02-types/06-strings.html">String</a></li>
</ul>
<p>To read more about casting, conversions, and type policy, go to <a href="04-variables-and-types/02-types/07-casting-and-conversions.html">this chapter</a>.</p>
<p>You can declare type aliases in Zinc, which allow you to shorten type
signatures of complex types by giving them a name:</p>
<pre><code class="language-rust no_run noplaypen">type ComplexType = [(u8, [bool; 8], field); 16];

fn example(data: ComplexType) {}
</code></pre>
<h1><a class="header" href="#scalar-types" id="scalar-types">Scalar types</a></h1>
<p>Scalar types are also called primitive types and contain a single value.</p>
<h2><a class="header" href="#unit" id="unit">Unit</a></h2>
<p>The unit type and value are described with empty round parenthesis <code>()</code> and
have no differences from the same type in Rust. Values of that type are
implicitly returned from functions, blocks, and other expressions which do not
return a value explicitly. Also, this type can be used as a placeholder for
input, witness and output types of the <code>main</code> function.</p>
<p><code>()</code> is the literal for both unit type and value. The unit type values cannot be
used by any operators or casted back and forth.</p>
<p>The unit type can exist as a standalone value:</p>
<pre><code class="language-rust no_run noplaypen">let x = (); // ()
</code></pre>
<p>It is implicitly returned by blocks or functions:</p>
<pre><code class="language-rust no_run noplaypen">fn check(value: bool) {
    // several statements
};

let y = check(true); // y is ()
</code></pre>
<h2><a class="header" href="#boolean" id="boolean">Boolean</a></h2>
<p><code>bool</code> is the boolean type keyword.</p>
<p>Boolean value is represented as <code>field</code> with value set to either <code>0</code> or <code>1</code>.
To ensure type safety casting between boolean and integer types is not allowed.
In general, its behavior is indistinguishable from the same type from Rust or other
C-like languages.</p>
<h3><a class="header" href="#literals" id="literals">Literals</a></h3>
<p><code>true</code> and <code>false</code>.</p>
<h3><a class="header" href="#examples-1" id="examples-1">Examples</a></h3>
<pre><code class="language-rust no_run noplaypen">let a = true;
let b: bool = false;

if a &amp;&amp; !b {
    debug(a ^^ b);
};
</code></pre>
<h2><a class="header" href="#integer" id="integer">Integer</a></h2>
<p>Integer types are somewhat different from those of Rust since they are
extended to be able to use any size between 1 and 32 bytes. This feature was
borrowed from Solidity and it helps to reduce the number of constraints and
smart contract size. Internal integer representation uses the BN256 field of
different bitlength.</p>
<h3><a class="header" href="#types-1" id="types-1">Types</a></h3>
<ul>
<li><code>u8</code> .. <code>u248</code>: unsigned integers</li>
<li><code>i8</code> .. <code>i248</code>: signed integers</li>
<li><code>field</code>: the native field integer</li>
</ul>
<p>Integer types bitlength step equals 8, that is, only the following bitlengths
are possible: <code>8</code>, <code>16</code>, ..., <code>240</code>, <code>248</code>.</p>
<p>A <code>field</code> value is a native field element of the elliptic curve used in the
constraint system. It represents an unsigned integer of bitlength equal to the
field modulus length (e.g. for BN256 the field modulus length is <code>254</code> bit).</p>
<p>All the types are represented using <code>field</code> as their basic building block.
When an integer variable is allocated, its bitlength must be enforced in the
constraint system.</p>
<h3><a class="header" href="#literals-1" id="literals-1">Literals</a></h3>
<ul>
<li>decimal: <code>0</code>, <code>1</code>, <code>122</code>, <code>574839572494237242</code></li>
<li>hexadecimal: <code>0x0</code>, <code>0xfa</code>, <code>0x0001</code>, <code>0x1fffDEADffffffffffBEEFffff</code></li>
</ul>
<p>Following the Rust rules, only unsigned integer literals can be expressed, since
the unary minus is not a part of the literal but a standalone operator. Thus,
unsigned values can be implicitly casted to signed ones using the unary minus.</p>
<h3><a class="header" href="#casting" id="casting">Casting</a></h3>
<p>Casting is possible only to a type with greater bitlength. Probably, this
behavior will become less strict in the future.</p>
<h3><a class="header" href="#inference" id="inference">Inference</a></h3>
<p>If the literal type is not specified, the minimal possible bitlength is inferred.</p>
<h3><a class="header" href="#examples-2" id="examples-2">Examples</a></h3>
<pre><code class="language-rust no_run noplaypen">let a = 0; // u8
let a: i24 = 0; // i24
let b = 256; // u16
let c = -1;  // i8
let c = -129; // i16
let d = 0xff as field; // field
let e: field = 0; // field
</code></pre>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>Arrays are collections of values of the same type sequentially stored in the memory.</p>
<p>Fixed-sized arrays follow the Rust rules. The only exception is the restriction
to constant indexes, that is, you cannot index an array with anything but a
constant expression for now.</p>
<p>Arrays support the index and slice operators, which is explained in detail <a href="04-variables-and-types/02-types/../../05-operators/06-access.html">here</a>.</p>
<pre><code class="language-rust no_run noplaypen">let mut fibbonaci = [0, 1, 1, 2, 3, 5, 8, 13];
let element = fibbonaci[3];
fibbonaci[2] = 1;
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples are anonymous collections of values of different types, sequentially
stored in memory and gathered together due to some logical relations.</p>
<blockquote>
<p>Like in Rust, <code>()</code> is a void value, <code>(value)</code> is a parenthesized expression,
and <code>(value,)</code> is a tuple with one element.</p>
</blockquote>
<p>Tuple fields can be accessed via the dot operator, which is explained in detail <a href="04-variables-and-types/02-types/../../05-operators/06-access.html">here</a>.</p>
<pre><code class="language-rust no_run noplaypen">let mut tuple: (u8, field) = (0xff, 0 as field);
tuple.0 = 42;
dbg!(&quot;{}&quot;, tuple.1);
</code></pre>
<h1><a class="header" href="#structures" id="structures">Structures</a></h1>
<p>The structure is a custom data type that lets you name and package together
multiple related values that make up a meaningful group. Structures allow you
to easily build complex data types and pass them around your code with as little
verbosity as possible.</p>
<p>Structure fields can be accessed via the dot operator, which is explained in
detail <a href="04-variables-and-types/02-types/../../05-operators/06-access.html">here</a>.</p>
<pre><code class="language-rust no_run noplaypen">struct Person {
    age: u8,
    id: u64,
}

let mut person = Person {
    age: 24,
    id: 123456789 as u64,
};
person.age = 25;
</code></pre>
<h1><a class="header" href="#enumerations" id="enumerations">Enumerations</a></h1>
<p>Enums allow you to define a type by enumerating its possible values. Only simple
C-like enums are supported for now, which are groups of constants, following
the Rust syntax:</p>
<pre><code class="language-rust no_run noplaypen">enum Order {
    FIRST = 0,
    SECOND = 1,
}
</code></pre>
<p>Enum values can be used with <code>match</code> expressions to define the behavior in every
possible case:</p>
<pre><code class="language-rust no_run noplaypen">let value = Order::FIRST;
let result = match value {
    Order::FIRST =&gt; do_this(),
    Order::SECOND =&gt; do_that(),
};
</code></pre>
<p>The enum values can be implicitly casted to unsigned integers of enough
bitlength using <code>let</code> statements or explicitly using the <code>as</code> operator:</p>
<pre><code class="language-rust no_run noplaypen">let x = Order::FIRST; // the type is Order (inference)
let y: u8 = Order::SECOND; // the type is u8 (implicit casting)
let z = Order::SECOND as u8; // the type is u8 (explicit casting)
</code></pre>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>For now, strings have very limited implementation and usability.</p>
<p>The string type exists only in the literal form and can only appear in <code>dbg</code> and
<code>assert</code> built-in functions:</p>
<pre><code class="language-rust no_run noplaypen">dbg!(&quot;{}&quot;, 42);

assert!(true != false, &quot;a very obvious fact&quot;);
</code></pre>
<h1><a class="header" href="#casting-and-conversions" id="casting-and-conversions">Casting and conversions</a></h1>
<p>The language enforces static strong explicit type semantics. It is the most
strict type system available since reliability is above everything. However,
some inference abilities will not do any harm, so you do not have to specify
types in places where they are highly obvious.</p>
<h2><a class="header" href="#explicit" id="explicit">Explicit</a></h2>
<p>Type conversions can be only performed on the integer and enumeration types with
the casting operator. <a href="04-variables-and-types/02-types/../../05-operators/05-casting.html">This chapter</a> explains
the operator's behavior in detail.</p>
<h2><a class="header" href="#implicit" id="implicit">Implicit</a></h2>
<p>The <code>let</code> statement can perform implicit type casting of integers if the type
is specified to the left of the assignment symbol. Let us examine the statement:</p>
<pre><code class="language-rust no_run noplaypen">let a: field = 42 as u32;
</code></pre>
<ol>
<li><code>42</code> is inferred as a value of type <code>u8</code>.</li>
<li><code>42</code> is cast from <code>u8</code> to <code>u32</code>.</li>
<li>The expression <code>42 as u32</code> result is cast to <code>field</code>.</li>
<li>The field value is assigned to the variable <code>a</code>.</li>
</ol>
<p>The second case of implicit casting is the negation operator, which always
returns a signed integer type value of the same bitlength, regardless of the
input argument.</p>
<pre><code class="language-rust no_run noplaypen">let positive = 100; // u8
let negative = -positive; // i8
</code></pre>
<p><a href="04-variables-and-types/02-types/../../05-operators/01-arithmetic.html">This chapter</a> describes the negation operator
with more detail.</p>
<h2><a class="header" href="#inference-1" id="inference-1">Inference</a></h2>
<p>For now, Zinc infers types in two cases: integer literals and <code>let</code> bindings.</p>
<p>Integer literals are always inferred as values of the minimal possible size.
That is, <code>255</code> is a <code>u8</code> value, whereas <code>256</code> is a <code>u16</code> value. Signed integers
must be implicitly cast using the negation operator.</p>
<p>The <code>let</code> statement can infer types in case its type is not specified.</p>
<pre><code class="language-rust no_run noplaypen">let value = 0xffffffff_ffffffff_ffffffff_ffffffff;
</code></pre>
<p>In the example above, the <code>value</code> variable gets type <code>u128</code>, since 128 bytes
are enough to represent the value <code>0xffffffff_ffffffff_ffffffff_ffffffff</code>;</p>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<p>The function is the only callable type in Zinc and it closely follows the Rust
syntax. However, R1CS specifics require that functions must be executed completely,
thus there is no <code>return</code> statement in Zinc. The only way to return a value is
to specify it as the last unterminated statement of the function block.</p>
<p>Functions consist of several parts: the name, arguments, return type, and the
code block. The function name uniquely defines the function within its namespace.
The arguments can be only passed by value, and the function result can only be
returned by value. If the return type is omitted, the function is considered
to return a void value <code>()</code>. The code block can access the global scope,
but it has no information about where the function has been called from.</p>
<pre><code class="language-rust no_run noplaypen">const GLOBAL: u8 = 31;

fn wierd_sum(a: u8, b: u8) -&gt; u8 {
    side_effect(); // a statement
    a + b + GLOBAL // return value
}

let result = wierd_sum(42, 27);
assert!(result == 100, &quot;the weird sum is incorrect&quot;);
</code></pre>
<h1><a class="header" href="#operators" id="operators">Operators</a></h1>
<p>Operators of the Zinc language can be divided into several groups:</p>
<ul>
<li><a href="05-operators/./01-arithmetic.html">Arithmetic</a></li>
<li><a href="05-operators/./02-bitwise.html">Bitwise</a></li>
<li><a href="05-operators/./03-comparison.html">Comparison</a></li>
<li><a href="05-operators/./04-logical.html">Logical</a></li>
<li><a href="05-operators/./05-casting.html">Casting</a></li>
<li><a href="05-operators/./06-access.html">Access</a></li>
<li><a href="05-operators/./07-range.html">Range</a></li>
<li><a href="05-operators/./08-assignment.html">Assignment</a></li>
</ul>
<p># Precedence</p>
<p>The top one is executed first.</p>
<table><thead><tr><th>Operator</th><th>Associativity</th></tr></thead><tbody>
<tr><td>::</td><td>left to right</td></tr>
<tr><td>[] .</td><td>left to right</td></tr>
<tr><td>- ~ !</td><td>unary</td></tr>
<tr><td>as</td><td>left to right</td></tr>
<tr><td>* / %</td><td>left to right</td></tr>
<tr><td>+ -</td><td>left to right</td></tr>
<tr><td>&lt;&lt; &gt;&gt;</td><td>left to right</td></tr>
<tr><td>&amp;</td><td>left to right</td></tr>
<tr><td>^</td><td>left to right</td></tr>
<tr><td></td><td>left to right</td></tr>
<tr><td>== != &lt;= &gt;= &lt; &gt;</td><td>require parentheses</td></tr>
<tr><td>&amp;&amp;</td><td>left to right</td></tr>
<tr><td>^^</td><td>left to right</td></tr>
<tr><td></td><td>left to right</td></tr>
<tr><td>.. ..=</td><td>require parentheses</td></tr>
<tr><td>= += -= *= /= %= = ^= &amp;= &lt;&lt;= &gt;&gt;=</td><td>require parentheses</td></tr>
</tbody></table>
<h1><a class="header" href="#arithmetic-operators" id="arithmetic-operators">Arithmetic operators</a></h1>
<p>Arithmetic operators do not perform any kind of overflow checking at
compile time. If an overflow happens, the Zinc VM will fail at runtime.</p>
<blockquote>
<p>When it comes to the division of negative numbers, Zinc follows the Euclidean
division concept. It means that <code>-45 % 7 == 4</code>. To get the detailed explanation
and some examples, see the <a href="https://en.wikipedia.org/wiki/Euclidean_division">article</a>.</p>
</blockquote>
<p>The <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> shortcut operators perform the operation
and assign the result to the first operand. The first operand must be a mutable memory location
like a variable, array element, or structure field.</p>
<h4><a class="header" href="#addition" id="addition">Addition</a></h4>
<p><code>+</code> and <code>+=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#subtraction" id="subtraction">Subtraction</a></h4>
<p><code>-</code> and <code>-=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#multiplication" id="multiplication">Multiplication</a></h4>
<p><code>*</code> and <code>*=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#division" id="division">Division</a></h4>
<p><code>/</code> and <code>/=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#remainder" id="remainder">Remainder</a></h4>
<p><code>%</code> and <code>%=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#negation" id="negation">Negation</a></h4>
<p><code>-</code> is an unary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
</ol>
<p><strong>Returns</strong> a signed integer with the same bitlength.</p>
<h1><a class="header" href="#bitwise-operators" id="bitwise-operators">Bitwise operators</a></h1>
<p>The <code>|=</code>, <code>^=</code>, <code>&amp;=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code> shortcut operators perform the operation
and assign the result to the first operand. The first operand must be a mutable memory location
like a variable, array element, or structure field.</p>
<blockquote>
<p>For now, bitwise operators are allowed for constants only. Witness data will be covered soon.</p>
</blockquote>
<h4><a class="header" href="#bitwise-or" id="bitwise-or">Bitwise OR</a></h4>
<p><code>|</code> and <code>|=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#bitwise-xor" id="bitwise-xor">Bitwise XOR</a></h4>
<p><code>^</code> and <code>^=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#bitwise-and" id="bitwise-and">Bitwise AND</a></h4>
<p><code>&amp;</code> and <code>&amp;=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> an integer result of the same type.</p>
<h4><a class="header" href="#bitwise-shift-left" id="bitwise-shift-left">Bitwise shift left</a></h4>
<p><code>&lt;&lt;</code> and <code>&lt;&lt;=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Constant integer expression</li>
</ol>
<p><strong>Returns</strong> an integer result of the operand 1 type.</p>
<h4><a class="header" href="#bitwise-shift-right" id="bitwise-shift-right">Bitwise shift right</a></h4>
<p><code>&gt;&gt;</code> and <code>&gt;&gt;=</code> are binary operators.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
<li>Constant integer expression</li>
</ol>
<p><strong>Returns</strong> an integer result of the operand 1 type.</p>
<h4><a class="header" href="#bitwise-not" id="bitwise-not">Bitwise NOT</a></h4>
<p><code>~</code> is an unary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression (any type except <code>field</code>)</li>
</ol>
<p><strong>Returns</strong> an integer result.</p>
<h1><a class="header" href="#comparison-operators" id="comparison-operators">Comparison operators</a></h1>
<h4><a class="header" href="#equality" id="equality">Equality</a></h4>
<p><code>==</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#non-equality" id="non-equality">Non-equality</a></h4>
<p><code>!=</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer <strong>or</strong> boolean expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#lesser-or-equals" id="lesser-or-equals">Lesser or equals</a></h4>
<p><code>&lt;=</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#greater-or-equals" id="greater-or-equals">Greater or equals</a></h4>
<p><code>&gt;=</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#lesser" id="lesser">Lesser</a></h4>
<p><code>&lt;</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#greater" id="greater">Greater</a></h4>
<p><code>&gt;</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h1><a class="header" href="#logical-operators" id="logical-operators">Logical operators</a></h1>
<h4><a class="header" href="#or" id="or">OR</a></h4>
<p><code>||</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#xor" id="xor">XOR</a></h4>
<p><code>^^</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#and" id="and">AND</a></h4>
<p><code>&amp;&amp;</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h4><a class="header" href="#not" id="not">NOT</a></h4>
<p><code>!</code> is an unary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Boolean expression</li>
</ol>
<p><strong>Returns</strong> the boolean result.</p>
<h1><a class="header" href="#casting-operator" id="casting-operator">Casting operator</a></h1>
<p><code>as</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Expression of any type</li>
<li>Expression of the same or integer type</li>
</ol>
<p><strong>Returns</strong> the casted value.</p>
<p>Casting allowed:</p>
<ul>
<li>from integer to integer</li>
<li>from enum to integer</li>
<li>to the same type (no effect, no errors)</li>
</ul>
<pre><code class="language-rust no_run noplaypen">enum Order {
    First = 1,
}

let a = 1; // inferred as u8
let b = a as i8; // explicit casting to the opposite sign
let c: u8 = Order::First; // implicit casting to an integer
</code></pre>
<h1><a class="header" href="#access-operators" id="access-operators">Access operators</a></h1>
<h4><a class="header" href="#path-resolution" id="path-resolution">Path resolution</a></h4>
<p><code>::</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Namespace identifier (module, structure, enumeration)</li>
<li>Item identifier (module, type, variable, constant etc.)</li>
</ol>
<p><strong>Returns</strong> the second operand.</p>
<h4><a class="header" href="#array-indexing" id="array-indexing">Array indexing</a></h4>
<p><code>[]</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Array expression</li>
<li>Integer or range expression</li>
</ol>
<p><strong>Returns</strong> an array element (if the 2nd operand is an integer) or a sub-array
(if the 2nd operand is a range).</p>
<h4><a class="header" href="#field-access" id="field-access">Field access</a></h4>
<p><code>.</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Tuple or structure expression</li>
<li>Tuple index or structure field name</li>
</ol>
<p><strong>Returns</strong> a tuple or structure element.</p>
<h1><a class="header" href="#range-operators" id="range-operators">Range operators</a></h1>
<h4><a class="header" href="#range" id="range">Range</a></h4>
<p><code>..</code> is a binary operator.</p>
<p>Range operator is used only for loop bounds or array slicing.</p>
<p>The operator can accept operands of different integer types. The result will
be signed if any of the operands if signed, and the bitlength will be enough
to contain the greater range bound.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Constant integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> a temporary range element to be used as a slice or loop range.</p>
<h4><a class="header" href="#inclusive-range" id="inclusive-range">Inclusive range</a></h4>
<p><code>..=</code> is a binary operator.</p>
<p>The same as the above, but the right range bound is inclusive.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Constant integer expression</li>
<li>Expression of the operand 1 type</li>
</ol>
<p><strong>Returns</strong> a temporary range element to be used as a slice or loop range.</p>
<h1><a class="header" href="#assignment-operator" id="assignment-operator">Assignment operator</a></h1>
<p><code>=</code> is a binary operator.</p>
<p><strong>Accepts</strong></p>
<ol>
<li>Place expression (a descriptor of a memory place, e.g. a variable or array element)</li>
<li>Value expression</li>
</ol>
<p><strong>Returns</strong> <code>()</code>.</p>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>Expressions consist of operands and operators.</p>
<p>Operators have already been described in <a href="06-expressions/../05-operators/00-overview.html">this chapter</a>.</p>
<h2><a class="header" href="#operands" id="operands">Operands</a></h2>
<p>Any syntax constructions computed into values can be used in expressions.
Zinc does all the type checking at compile-time, so you can build expressions
of arbitrary complexity without caring about type safety.
However, you should care about readability and maintainability, since there are
probably other people going to work with your code.</p>
<h1><a class="header" href="#literals-2" id="literals-2">Literals</a></h1>
<p>Simple literal operands are the basic elements of an expression:</p>
<ul>
<li><code>42</code> - integer</li>
<li><code>false</code> - boolean</li>
<li><code>&quot;error&quot;</code> - string</li>
<li><code>u128</code> - type (in casting clauses like <code>42 as u128</code>)</li>
</ul>
<p>There are several complex operands worth mentioning. As you will see from the
examples, you can nest these constructions as much as you need, but do not abuse
this ability too much.</p>
<h2><a class="header" href="#array" id="array">Array</a></h2>
<pre><code class="language-rust no_run noplaypen">let array = [
    1,
    2,
    3,
    4,
    5,
    1 + 5,
    { let t = 5; t * t },
];
</code></pre>
<p>The inner type and array length are inferred by the compiler.</p>
<h2><a class="header" href="#tuple" id="tuple">Tuple</a></h2>
<pre><code class="language-rust no_run noplaypen">let tuple = (42, true, [1, 2, 3]);
</code></pre>
<p>The inner types and the tuple type are inferred by the compiler.</p>
<h2><a class="header" href="#structure" id="structure">Structure</a></h2>
<pre><code class="language-rust no_run noplaypen">struct Data {
    value: field,
}

let data = Data {
    value: 0,
};
</code></pre>
<h1><a class="header" href="#blocks" id="blocks">Blocks</a></h1>
<p>A block expression consists of zero or more statements and an optional result
expression. Every block starts a new scope of visibility.</p>
<pre><code class="language-rust no_run noplaypen">let c = {
    let a = 5;
    let b = 10;
    a + b
};
</code></pre>
<h1><a class="header" href="#conditionals" id="conditionals">Conditionals</a></h1>
<h2><a class="header" href="#if" id="if"><code>if</code></a></h2>
<p>An <code>if</code> conditional expression consists of the condition, main block, and optional
<code>else</code> block. Every block starts a new scope of visibility.</p>
<pre><code class="language-rust no_run noplaypen">let condition = true;
let c = if condition {
    let a = 5;
    a
} else {
    let b = 10;
    b
};
</code></pre>
<h2><a class="header" href="#match" id="match"><code>match</code></a></h2>
<p>The match expression is a syntactic sugar for nested conditional
expressions. Each branch block starts a new scope of visibility.</p>
<pre><code class="language-rust no_run noplaypen">let value = MyEnum::ValueOne;

match value {
    MyEnum::ValueOne =&gt; { ... }
    MyEnum::ValueTen =&gt; { ... }
    _ =&gt; { ... }
}
</code></pre>
<p>For now, only the following match patterns are supported:</p>
<ul>
<li>constant (e.g. <code>42</code>)</li>
<li>path (e.g. <code>MyEnum::ValueOne</code>)</li>
<li>variable binding (e.g. <code>value</code>)</li>
<li>wildcard (<code>_</code>)</li>
</ul>
<blockquote>
<p>Only simple types can be used as the <code>match</code> scrutinee for now,
this is, you cannot match an array, tuple or structure.</p>
</blockquote>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<p>The basic element of a Zinc program is a <strong>statement</strong>.</p>
<p>Statements are divided into several types:</p>
<ol>
<li>Declaration statements</li>
<li>Expression statements</li>
<li>Control statements</li>
</ol>
<h1><a class="header" href="#declaration-statements" id="declaration-statements">Declaration statements</a></h1>
<p>The declaration statements declare a new item, that is, a type, variable or module.</p>
<h2><a class="header" href="#let-variable-declaration" id="let-variable-declaration"><code>let</code> variable declaration</a></h2>
<p><code>let [mut] {identifier}[: {type}] = {expression};</code></p>
<p>The <code>let</code> declaration behaves just like in Rust, but it does not allow
uninitialized variables.</p>
<p>The type is optional and is used mostly to cast integer literal or double-check
the expression result type, otherwise, it is inferred.</p>
<pre><code class="language-rust no_run noplaypen">let mut variable: field = 0;
</code></pre>
<h2><a class="header" href="#type-alias-declaration" id="type-alias-declaration"><code>type</code> alias declaration</a></h2>
<p><code>type {identifier} = {type};</code></p>
<p>The <code>type</code> statement declares a type alias to avoid repeating complex types.</p>
<pre><code class="language-rust no_run noplaypen">type Alias = (field, u8, [field; 8]);
</code></pre>
<h2><a class="header" href="#struct-type-declaration" id="struct-type-declaration"><code>struct</code> type declaration</a></h2>
<p>The <code>struct</code> statement declares a structure.</p>
<pre><code class="language-rust no_run noplaypen">struct Data {
    a: field,
    b: u8,
    c: (),
}
</code></pre>
<h2><a class="header" href="#enum-type-declaration" id="enum-type-declaration"><code>enum</code> type declaration</a></h2>
<p>The <code>enum</code> statement declares an enumeration.</p>
<pre><code class="language-rust no_run noplaypen">enum List {
    A = 1,
    B = 2,
    C = 3,
}
</code></pre>
<h2><a class="header" href="#fn-type-declaration" id="fn-type-declaration"><code>fn</code> type declaration</a></h2>
<p>The <code>fn</code> statement declares a function.</p>
<pre><code class="language-rust no_run noplaypen">fn sum(a: u8, b: u8) -&gt; u8 {
    a + b
}
</code></pre>
<h2><a class="header" href="#impl-namespace-declaration" id="impl-namespace-declaration"><code>impl</code> namespace declaration</a></h2>
<p>The <code>impl</code> statement declares a namespace of a structure or enumeration.</p>
<pre><code class="language-rust no_run noplaypen">struct Data {
    value: field,
}

impl Data {
    fn print(data: Self) {
        dbg!(&quot;{}&quot;, data.value);
    }
}
</code></pre>
<h2><a class="header" href="#mod-module-declaration" id="mod-module-declaration"><code>mod</code> module declaration</a></h2>
<p><code>mod {identifier};</code></p>
<p>The <code>mod</code> statement declares a new module and behaves the same way as in Rust.</p>
<h2><a class="header" href="#use-module-import" id="use-module-import"><code>use</code> module import</a></h2>
<p><code>use {path};</code></p>
<p>The <code>use</code> statement imports an item from another namespace and behaves the same
way as in Rust.</p>
<h1><a class="header" href="#expression-statements" id="expression-statements">Expression statements</a></h1>
<h2><a class="header" href="#expression" id="expression">Expression</a></h2>
<p>The expression statement is an expression terminated with a <code>;</code> to ignore its
result. The most common use is the assignment to a mutable variable:</p>
<pre><code class="language-rust no_run noplaypen">let mut a = 0;
a = 42; // an expression statement ignoring the '()' result of the assignment
</code></pre>
<p>For more information on expressions, check <a href="07-statements/../06-expressions/00-overview.html">this chapter</a>.</p>
<h2><a class="header" href="#semicolons" id="semicolons">Semicolons</a></h2>
<p>In contrast with Rust, expression statements in Zinc must be always terminated
with <code>;</code> to get rid of some ambiguities regarding block and conditional
expressions. Let us compare the examples of Rust and Zinc to illustrate the
problem.</p>
<pre><code class="language-rust no_run noplaypen">fn blocks() -&gt; i32 {
    {
        get_unit()
    } // a statement, but only because the block result is ()
    {
        get_integer()
    } // a return expression, only because the block result is an integer
}
</code></pre>
<p>In the Rust example above, the blocks are completely identical, but their semantic
meaning depends on the block return type. Zinc solves this problem by enforcing
all expression statements to be explicitly terminated with a semicolon, like in
the following Zinc example:</p>
<pre><code class="language-rust no_run noplaypen">fn blocks() -&gt; i32 {
    {
        get_unit()
    }; // a statement, because it is explicitly terminated with a semicolon
    {
        get_integer()
    } // a return expression, because it goes the last in the function block
}
</code></pre>
<p>Conditional and match expressions follow the same rules as simple blocks.</p>
<h1><a class="header" href="#control-statements" id="control-statements">Control statements</a></h1>
<p>Control statements neither ignore the result nor declare a new item. The
only such statement is the <code>for-while</code> loop.</p>
<h2><a class="header" href="#for-while-loop" id="for-while-loop"><code>for-while</code> loop</a></h2>
<pre><code class="language-rust no_run noplaypen">for {identifier} in {range} [while {expression}] {
    ...
}
</code></pre>
<p>The <code>for</code> loop statement behaves just like in Rust, but it is merged with the
<code>while</code> loop, so the optional <code>while</code> condition is checked before each iteration
of the loop. The <code>while</code> condition expression has access to the inner scope and
can use its variables and the loop iterator.</p>
<pre><code class="language-rust no_run noplaypen">for i in 0..10 while i % x != 8 {
    // do something
};
</code></pre>
<p>Only constant expressions can be used as the bounds of the iterator range. The
<code>while</code> condition will not cause an early return, but it will suppress the loop
body side effects.</p>
<p>Zinc is a Turing-incomplete language, as it is dictated by R1CS restrictions, so
loops always have a fixed number of iterations. On the one hand, the loop counter
can be optimized to be treated as a constant, reducing the circuit cost, but on
the other hand, you cannot force a loop to return early, increasing the circuit
cost.</p>
<h2><a class="header" href="#if-and-match" id="if-and-match"><code>if</code> and <code>match</code></a></h2>
<p>The <a href="07-statements/../06-expressions/03-conditionals.html">conditional and match</a> expressions
can act as control statements, ignoring the returned value. To use them in such
role, just terminate the expression with a semicolon:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unknown(value: u8) -&gt; u8 {
    match value {
        1 =&gt; dbg!(&quot;One!&quot;),
        2 =&gt; dbg!(&quot;Two!&quot;),
        _ =&gt; dbg!(&quot;Perhaps, three!&quot;),
    };
    42
}}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#virtual-machine" id="virtual-machine">Virtual machine</a></h1>
<p>Zinc code is compiled into bytecode which can be run by Zinc VM.</p>
<p>Zinc VM is a virtual machine that serves three purposes: executing arbitrary
computations, generating zero-knowledge proof of performed computations, and
verification of the provided proof without knowing the input data.</p>
<p>Zinc VM is a stack-based virtual machine which is similar to many others like
the Python VM. Even though the VM is designed considering specifics and
limitations of zero-knowledge computations, bytecode instructions only
manipulate data on the stack while all zero-knowledge constraints are
automatically applied by the virtual machine.</p>
<h1><a class="header" href="#zargo-circuit-manager" id="zargo-circuit-manager">Zargo circuit manager</a></h1>
<p><code>Zargo</code> is a circuit managing tool, which can create, build, and use circuits
to generate and verify proofs.</p>
<h2><a class="header" href="#commands-overview" id="commands-overview">Commands overview</a></h2>
<p>All the commands have default values, so you may omit them in normal circumstances.
See <code>zargo --help</code> for more detail.</p>
<h3><a class="header" href="#new" id="new"><code>new</code></a></h3>
<p>Creates a new project directory with <code>Zargo.toml</code> manifest file and <code>src/main.zn</code>
circuit entry point module.</p>
<h3><a class="header" href="#init" id="init"><code>init</code></a></h3>
<p>Initializes a new project in an existing directory, creates missing files.</p>
<h3><a class="header" href="#build" id="build"><code>build</code></a></h3>
<p>Builds the circuit. The build consists of:</p>
<ul>
<li>the bytecode file</li>
<li>secret input JSON template</li>
<li>public data JSON template</li>
</ul>
<h3><a class="header" href="#clean" id="clean"><code>clean</code></a></h3>
<p>Removes the build directory.</p>
<h3><a class="header" href="#run" id="run"><code>run</code></a></h3>
<p>Build and runs the circuit on the Zinc VM, writes the result to the terminal.</p>
<h3><a class="header" href="#setup" id="setup"><code>setup</code></a></h3>
<p>Generates parameters for the prover using the circuit bytecode.</p>
<h3><a class="header" href="#prove" id="prove"><code>prove</code></a></h3>
<p>Generates the proof using the circuit bytecode, parameters generated with <code>setup</code>,
and provided public data.</p>
<h3><a class="header" href="#verify" id="verify"><code>verify</code></a></h3>
<p>Verifies the proof using the circuit bytecode, parameters generated with <code>setup</code>,
proof generated with <code>prove</code>, and provided public data.</p>
<h3><a class="header" href="#proof-check" id="proof-check"><code>proof-check</code></a></h3>
<p>Executes the full cycle of proof verification, that is, performs
<code>run</code> + <code>setup</code> + <code>prove</code> + <code>verify</code>. Mostly for testing purposes.</p>
<h2><a class="header" href="#workflow-example" id="workflow-example">Workflow example</a></h2>
<h3><a class="header" href="#short" id="short">Short</a></h3>
<pre><code class="language-bash"># create a new circuit called 'zircuit'
zargo new zircuit
cd zircuit/

# write some code

# run the full verification cycle
zargo proof-check
</code></pre>
<h3><a class="header" href="#long" id="long">Long</a></h3>
<pre><code class="language-bash"># create a new circuit called 'zircuit'
zargo new zircuit
cd zircuit/

# write some code

# build the circuit
zargo build

# run the circuit and print the result
zargo run

# generate the prover parameters
zargo setup

# edit the 'build/witness.json' and 'build/public-data.json' files

# generate the proof
zargo prove

# verify the proof
zargo verify
</code></pre>
<h2><a class="header" href="#manifest-file" id="manifest-file">Manifest file</a></h2>
<p>A Zinc circuit is described with the manifest file <code>Zargo.toml</code> with the
following structure:</p>
<pre><code class="language-toml">[circuit]
name = &quot;test&quot;
version = &quot;0.1.0&quot;
</code></pre>
<h1><a class="header" href="#schnorr-signature-tool" id="schnorr-signature-tool">Schnorr signature tool</a></h1>
<p>The <code>schnorr</code> signature tool can perform the following actions:</p>
<ul>
<li>generate a private key</li>
<li>sign a message with a private key</li>
<li>extract the public key from a private key</li>
</ul>
<h3><a class="header" href="#generating-a-private-key" id="generating-a-private-key">Generating a private key</a></h3>
<pre><code class="language-bash">schnorr gen-key &gt; 'private_key.txt'
</code></pre>
<h3><a class="header" href="#signing-a-message-with-a-private-key" id="signing-a-message-with-a-private-key">Signing a message with a private key</a></h3>
<p>From file:</p>
<pre><code class="language-bash">schnorr sign --key 'private_key.txt' --message 'message.txt'
</code></pre>
<p>From <code>stdin</code>:</p>
<pre><code class="language-bash">schnorr sign --key 'private_key.txt' --message -
</code></pre>
<p>The JSON output can be used as witness data if you want to pass the signature to a circuit.</p>
<h3><a class="header" href="#extracting-the-public-key" id="extracting-the-public-key">Extracting the public key</a></h3>
<pre><code class="language-bash">schnorr pub-key &lt; 'private_key.txt' &gt; 'public_key.txt'
</code></pre>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in
your Zinc journey.</p>
<h1><a class="header" href="#lexical-grammar-ebnf" id="lexical-grammar-ebnf">Lexical grammar (EBNF)</a></h1>
<pre><code>lexeme = comment | identifier | keyword | literal | symbol | EOF ;

comment = single_line_comment | multi_line_comment ;
single_line_comment = '//', ( ? ANY ? - '\n' | EOF ), '\n' | EOF ;
multi_line_comment = '/*', ( ? ANY ? - '*/' ), '*/' ;

identifier = (
    alpha, { alpha | digit | '_' }
  | '_', alpha, { alpha }
- keyword ) ;

keyword =
    'let'
  | 'mut'
  | 'const'
  | 'type'
  | 'struct'
  | 'enum'
  | 'fn'
  | 'mod'
  | 'use'
  | 'impl'

  | 'for'
  | 'in'
  | 'while'
  | 'if'
  | 'else'
  | 'match'

  | 'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'

  | 'true'
  | 'false'

  | 'as'

  | 'Self'
;

literal = boolean | integer | string ;
boolean = 'true' | 'false' ;
integer =
    '0'
  | digit - '0', { digit }
  | '0x', hex_digit, { hex_digit }
;
string = '&quot;', { ANY - '&quot;' | '\', ANY }, '&quot;' ;

symbol =
    '('
  | ')'
  | '['
  | ']'
  | '{'
  | '}'
  | '_'
  | '.'
  | ':'
  | ';'
  | ','
  | '='
  | '+'
  | '-'
  | '*'
  | '/'
  | '%'
  | '\'
  | '!'
  | '&lt;'
  | '&gt;'
  | '|'
  | '&amp;'
  | '^'
  | '~'
  | '&lt;&lt;'
  | '&gt;&gt;'
  | '+='
  | '-='
  | '*='
  | '/='
  | '%='
  | '|='
  | '&amp;='
  | '^='
  | '::'
  | '=='
  | '!='
  | '&lt;='
  | '&gt;='  
  | '&amp;&amp;'
  | '^^'
  | '||'
  | '..'
  | '..='
  | '&lt;&lt;='
  | '&gt;&gt;='
  | '=&gt;'
  | '-&gt;'
;

alpha =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'
  | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N'
  | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U'
  | 'V' | 'W' | 'X' | 'Y' | 'Z' 
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g'
  | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n'
  | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u'
  | 'v' | 'w' | 'x' | 'y' | 'z'
;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

hex_digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  | 'A' | 'B' | 'C' | 'D' | 'E' | 'F'
  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f'
;

</code></pre>
<h3><a class="header" href="#the-zinc-alphabet" id="the-zinc-alphabet">The Zinc alphabet</a></h3>
<table><thead><tr><th>Group</th><th>Characters</th></tr></thead><tbody>
<tr><td>whitespaces</td><td>\t \n \r <Space></td></tr>
<tr><td>lowercase</td><td>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</td></tr>
<tr><td>uppercase</td><td>a b c d e f g h i j k l m n o p q r s t u v w x y z</td></tr>
<tr><td>numbers</td><td>0 1 2 3 4 5 6 7 8 9</td></tr>
<tr><td>symbols</td><td>+ - * / % &lt; = &gt;  &amp; ^ _ ! ~ ( ) [ ] { } &quot; , . : ;</td></tr>
</tbody></table>
<h1><a class="header" href="#syntax-grammar-ebnf" id="syntax-grammar-ebnf">Syntax grammar (EBNF)</a></h1>
<pre><code>file = { module_local_statement } ;

(* Statements *)
module_local_statement =
    const_statement
  | type_statement
  | struct_statement
  | enum_statement
  | fn_statement
  | mod_statement
  | use_statement
  | impl_statement
  | empty_statement
;

function_local_statement =
    let_statement
  | const_statement
  | loop_statement
  | empty_statement
  | expression
;

implementation_local_statement =
    const_statement
  | fn_statement
  | empty_statement
;

type_statement = 'type', identifier, '=', type ;
struct_statement = 'struct', '{', field_list, '}' ;
enum_statement = 'enum', '{', variant_list, '}' ;
fn_statement = 'fn', identifier, '(', field_list, ')', [ '-&gt;', type ], block_expression ;
mod_statement = 'mod', identifier ;
use_statement = 'use', path_expression ;
impl_statement = 'impl', identifier, '{', { implementation_local_statement }, '}' ;
const_statement = 'const', identifier, ':', type, '=', expression ;
let_statement = 'let', [ 'mut' ], identifier, [ ':', type ], '=', expression ;
loop_statement = 'for', identifier, 'in', expression, [ 'while', expression ], block_expression ;
empty_statement = ';' ;

(* Expressions *)
expression = operand_assignment, [ '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&lt;&lt;=' | '&gt;&gt;=' | '|=' | '^=' | '&amp;=', operand_assignment ] ;
operand_assignment = operand_range, [ '..' | '..=', operand_range ] ;
operand_range = operand_or, { '||', operand_or } ;
operand_or = operand_xor, { '^^', operand_xor } ;
operand_xor = operand_and, { '&amp;&amp;', operand_and } ;
operand_and = operand_comparison, [ '==' | '!=' | '&gt;=' | '&lt;=' | '&gt;' | '&lt;', operand_comparison ] ;
operand_comparison = operand_bitwise_or, { '|', operand_bitwise_or } ;
operand_bitwise_or = operand_bitwise_xor, { '^', operand_bitwise_xor } ;
operand_bitwise_xor = operand_bitwise_and, { '&amp;', operand_bitwise_and } ;
operand_bitwise_and = operand_bitwise_shift, { '&lt;&lt;' | '&gt;&gt;', operand_bitwise_shift } ;
operand_bitwise_shift = operand_add_sub, { '+' | '-', operand_add_sub } ;
operand_add_sub = operand_mul_div_rem, { '*' | '/' | '%', operand_mul_div_rem } ;
operand_mul_div_rem = operand_as, { 'as', type } ;
operand_as = { '-' | '~' | '!' }, operand_access ;
operand_access = operand_path, {
    '[', expression, ']'
  | '.', integer | identifier
  | [ '!' ], '(', expression_list, ')'
} ;
operand_path = operand_terminal, { '::', operand_terminal } ;
operand_terminal =
    tuple_expression
  | block_expression
  | array_expression
  | conditional_expression
  | match_expression
  | struct_expression
  | literal
  | identifier
;

expression_list = [ expression, { ',', expression } ] ;

block_expression = '{', { function_local_statement }, [ expression ], '}' ;

conditional_expression = 'if', expression, block_expression, [ 'else', conditional_expression | block_expression ] ;

match_expression = 'match', expression, '{', { pattern_match, '=&gt;', expression, ',' }, '}' ;

array_expression =
    '[', [ expression, { ',', expression } ] ']'
  | '[', expression, ';', integer, ']'
;

tuple_expression =
    '(', ')'
  | '(', expression, ')'
  | '(', expression, ',', [ expression, { ',', expression } ], ')'
;

struct_expression = identifier, '{', field_list, '}';

(* Parts *)
type =
    '(', ')'
  | 'bool'
  | 'u8' | 'u16' | 'u24' | 'u32' | 'u40' | 'u48' | 'u56' | 'u64'
  | 'u72' | 'u80' | 'u88' | 'u96' | 'u104' | 'u112' | 'u120' | 'u128'
  | 'u136' | 'u144' | 'u152' | 'u160' | 'u168' | 'u176' | 'u184' | 'u192'
  | 'u200' | 'u208' | 'u216' | 'u224' | 'u232' | 'u240' | 'u248' | 'field'
  | 'i8' | 'i16' | 'i24' | 'i32' | 'i40' | 'i48' | 'i56' | 'i64'
  | 'i72' | 'i80' | 'i88' | 'i96' | 'i104' | 'i112' | 'i120' | 'i128'
  | 'i136' | 'i144' | 'i152' | 'i160' | 'i168' | 'i176' | 'i184' | 'i192'
  | 'i200' | 'i208' | 'i216' | 'i224' | 'i232' | 'i240' | 'i248'
  | 'field'
  | '[', type, ';', expression, ']'
  | '(', type, { ',', type }, ')'
  | expression
;

pattern_match =
    boolean
  | integer
  | identifier
  | operand_path
  | '_'
;

field = identifier, ':', type ;
field_list = [ field, { ',', field } ] ;

variant = identifier, '=', integer ;
variant_list = [ variant, { ',', variant } ] ;

</code></pre>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<h4><a class="header" href="#declarations" id="declarations">Declarations</a></h4>
<pre><code class="language-rust no_run noplaypen">let
mut
const
type
struct
enum
fn
use
mod
impl
contract
</code></pre>
<h4><a class="header" href="#controls" id="controls">Controls</a></h4>
<pre><code class="language-rust no_run noplaypen">for
in
while
if
else
match
</code></pre>
<h4><a class="header" href="#types-2" id="types-2">Types</a></h4>
<pre><code class="language-rust no_run noplaypen">bool
u8 u16 ... u240 u248
i8 i16 ... i240 i248
field
</code></pre>
<h4><a class="header" href="#literals-3" id="literals-3">Literals</a></h4>
<pre><code class="language-rust no_run noplaypen">true
false
</code></pre>
<h4><a class="header" href="#operators-1" id="operators-1">Operators</a></h4>
<pre><code class="language-rust no_run noplaypen">as
</code></pre>
<h4><a class="header" href="#special" id="special">Special</a></h4>
<pre><code class="language-rust no_run noplaypen">Self
self
</code></pre>
<h2><a class="header" href="#reserved" id="reserved">Reserved</a></h2>
<pre><code class="language-rust no_run noplaypen">self
static
pub
ref
extern
return
loop
break
continue
</code></pre>
<h1><a class="header" href="#built-in-functions-1" id="built-in-functions-1">Built-in functions</a></h1>
<h2><a class="header" href="#dbg-1" id="dbg-1"><code>dbg</code></a></h2>
<p>Prints its arguments to the terminal. Only for debugging purposes.</p>
<p>Arguments:</p>
<ul>
<li>format string literal (<code>str</code>)</li>
<li>rest of the arguments to print</li>
</ul>
<p>Return type: <code>()</code></p>
<p><strong>Note</strong>: This function is special, as it accepts an arbitrary number of arguments
of any type after the format string.</p>
<h2><a class="header" href="#assert-1" id="assert-1"><code>assert</code></a></h2>
<p>Checks if the boolean expression is true. If it is not, the circuit fails with
an error passed as the second argument.</p>
<p>Arguments:</p>
<ul>
<li>boolean expression (<code>bool</code>)</li>
<li>error message string literal (<code>str</code>)</li>
</ul>
<p>Return type: <code>()</code></p>
<h1><a class="header" href="#standard-library-1" id="standard-library-1">Standard library</a></h1>
<p>The standard library is unstable. Function signatures and behavior are going to
be changed in future releases.</p>
<p>Most of the functions described here are special, as they accept arrays of
arbitrary size. Since there are only fixed-size arrays in Zinc now, it would
be challenging to create a function for arrays of every possible size. It is
not possible to write such a function yourself using the language type
system, but <code>std</code> makes an exception to simplify development for now.</p>
<h2><a class="header" href="#definitions" id="definitions">Definitions</a></h2>
<ul>
<li><code>{scalar}</code> - a scalar type, which can be <code>bool</code>, <code>u{N}</code>, <code>i{N}</code>, <code>field</code></li>
<li><code>u{N}</code> - an unsigned integer of bitlength <code>N</code></li>
<li><code>i{N}</code> - a signed integer of bitlength <code>N</code></li>
<li><code>field</code> - a field element of bitlength <code>254</code></li>
</ul>
<h2><a class="header" href="#stdcrypto-module" id="stdcrypto-module"><code>std::crypto</code> module</a></h2>
<h3><a class="header" href="#stdcryptosha256" id="stdcryptosha256"><code>std::crypto::sha256</code></a></h3>
<p>Computes the <code>sha256</code> hash of a given bit array.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>preimage length is zero</li>
<li>preimage length is not multiple of 8</li>
</ul>
<p>Arguments:</p>
<ul>
<li>preimage bit array <code>[bool; N]</code></li>
</ul>
<p>Returns: 256-bit hash <code>[bool; 256]</code></p>
<h3><a class="header" href="#stdcryptopedersen" id="stdcryptopedersen"><code>std::crypto::pedersen</code></a></h3>
<p>Maps a bit array to a point on an elliptic curve.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>preimage length is zero</li>
<li>preimage length is greater than 512 bits</li>
</ul>
<p>To understand what is under the hood, see <a href="https://iden3-docs.readthedocs.io/en/latest/iden3_repos/research/publications/zkproof-standards-workshop-2/pedersen-hash/pedersen.html">this article</a>.</p>
<p>Arguments:</p>
<ul>
<li>preimage bit array <code>[bool; N]</code></li>
</ul>
<p>Returns: elliptic curve point coordinates <code>(field, field)</code></p>
<h3><a class="header" href="#stdcryptoeccpoint" id="stdcryptoeccpoint"><code>std::crypto::ecc::Point</code></a></h3>
<p>The elliptic curve point.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: field,
    y: field,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdcryptoschnorrsignature" id="stdcryptoschnorrsignature"><code>std::crypto::schnorr::Signature</code></a></h3>
<p>The Schnorr EDDSA signature structure.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Signature {
    r: std::crypto::ecc::Point,
    s: field,
    pk: std::crypto::ecc::Point,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#stdcryptoschnorrsignatureverify" id="stdcryptoschnorrsignatureverify"><code>std::crypto::schnorr::Signature::verify</code></a></h3>
<p>Verifies the EDDSA signature.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>message length is zero</li>
<li>message length is greater than 248 bits</li>
</ul>
<p>Arguments:</p>
<ul>
<li>the signature: <code>std::crypto::schnorr::Signature</code></li>
<li>the message: <code>[bool; N]</code></li>
</ul>
<p>Returns: the boolean result</p>
<h2><a class="header" href="#stdconvert-module" id="stdconvert-module"><code>std::convert</code> module</a></h2>
<h3><a class="header" href="#stdconvertto_bits" id="stdconvertto_bits"><code>std::convert::to_bits</code></a></h3>
<p>Converts a scalar value to a bit array of its bitlength.</p>
<p>Arguments:</p>
<ul>
<li>scalar value: <code>u{N}</code>, or <code>i{N}</code>, or <code>field</code></li>
</ul>
<p>Returns: <code>[bool; N]</code></p>
<h3><a class="header" href="#stdconvertfrom_bits_unsigned" id="stdconvertfrom_bits_unsigned"><code>std::convert::from_bits_unsigned</code></a></h3>
<p>Converts a bit array to an unsigned integer of the array's bitlength.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>bit array size is zero</li>
<li>bit array size is greater than 248 bits</li>
<li>bit array size is not multiple of 8</li>
</ul>
<p>Arguments:</p>
<ul>
<li>bit array: <code>[bool; N]</code></li>
</ul>
<p>Returns: <code>u{N}</code></p>
<h3><a class="header" href="#stdconvertfrom_bits_signed" id="stdconvertfrom_bits_signed"><code>std::convert::from_bits_signed</code></a></h3>
<p>Converts a bit array to a signed integer of the array's bitlength.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>bit array size is zero</li>
<li>bit array size is greater than 248 bits</li>
<li>bit array size is not multiple of 8</li>
</ul>
<p>Arguments:</p>
<ul>
<li>bit array: <code>[bool; N]</code></li>
</ul>
<p>Returns: <code>i{N}</code></p>
<h3><a class="header" href="#stdconvertfrom_bits_unsigned-1" id="stdconvertfrom_bits_unsigned-1"><code>std::convert::from_bits_unsigned</code></a></h3>
<p>Converts a bit array to a field element.</p>
<p>Arguments:</p>
<ul>
<li>bit array: <code>[bool; 254]</code></li>
</ul>
<p>Returns: <code>field</code></p>
<h2><a class="header" href="#stdarray-module" id="stdarray-module"><code>std::array</code> module</a></h2>
<h3><a class="header" href="#stdarrayreverse" id="stdarrayreverse"><code>std::array::reverse</code></a></h3>
<p>Reverses a given array.</p>
<p>Arguments:</p>
<ul>
<li>array: <code>[{scalar}; N]</code></li>
</ul>
<p>Returns: <code>[{scalar}; N]</code></p>
<h3><a class="header" href="#stdarraytruncate" id="stdarraytruncate"><code>std::array::truncate</code></a></h3>
<p>Truncates an array of size <code>N</code> to an array of size <code>new_length</code>.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>array size is lesser than new length</li>
<li>new length is not a constant expression</li>
</ul>
<p>Arguments:</p>
<ul>
<li>array: <code>[{scalar}; N]</code></li>
<li>new_length: <code>u{N}</code> or <code>field</code></li>
</ul>
<p>Returns: <code>[{scalar}; new_length]</code></p>
<h3><a class="header" href="#stdarraypad" id="stdarraypad"><code>std::array::pad</code></a></h3>
<p>Pads a given array with the given values.</p>
<p>Will cause a compile-error if either:</p>
<ul>
<li>array size is greater than new length</li>
<li>new length is not a constant expression</li>
</ul>
<p>Arguments:</p>
<ul>
<li>array: <code>[{scalar}; N]</code></li>
<li>new_length: <code>u{N}</code> or <code>field</code></li>
<li>fill_value: <code>{scalar}</code></li>
</ul>
<p>Returns: <code>[{scalar}; new_length]</code></p>
<h2><a class="header" href="#stdff-module" id="stdff-module"><code>std::ff</code> module</a></h2>
<h3><a class="header" href="#stdffinvert" id="stdffinvert"><code>std::ff::invert</code></a></h3>
<p>Inverts a finite field.</p>
<p>Arguments:</p>
<ul>
<li>value: <code>field</code></li>
</ul>
<p>Returns: <code>field</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
